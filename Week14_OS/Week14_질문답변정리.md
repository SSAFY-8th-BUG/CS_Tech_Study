# Week 14 - 질문/답변 정리

#### 권혁근
1. PCB란 ?
```
Process Metadata들을 저장해 놓는곳이 PCB이며 운영체제가 프로세스를 제어하기 위해 정보를 저장해 놓는 곳으로, 
프로세스의 상태 정보를 저장하는 구조체이다.
```
2. PCB가 왜 필요한가요?
```
CPU에서는 프로세스의 상태에 따라 교체작업이 이루어진다. 
이때, 앞으로 다시 수행할 대기 중인 프로세스에 관한 저장 값을 PCB에 저장해두는 것이다.
(이전 작업에 대한 내용을 기억하고 있다, CPU 레지스터들의 집합에다가 원래 수행되었던 것을 그대로 갔다가 집어 넣어 실행)
```
3. 메모리 맵은 pipe와 비교해 어떤 장점이 있나요
```
파일로 대용량 데이터를 공유 할 수 있으며 양방향 통신이다.
```
4. 선점형 스케줄링과 비선점형 스케줄링의 단점과 장점
```
선점형 : 비교적 응답이 빠르다는 장점이 있지만, 처리 시간을 예측하기 힘들고 높은 우선순위 프로세스들이 계속 들어오는 경우 오버헤드를 초래
비선점형 : 모든 프로세스에 대한 요구를 공정하게 처리할 수 있지만, 
          짧은 작업을 수행하는 프로세스가 긴 작업 종료 시까지 대기해야할 수도 있다. (콘베이 현상)
```
5. 프로세스의 상태중에 [running →ready]로 바뀌는 상태전이와  [ready→running]이 되는 상태전이는 무엇인가요?
```
 [ready→running] : 스케줄러 디스패치 (Scheduler Dispatch) - 준비 상태에 있는 프로세스 중 하나를 선택하여 실행시키는 것.
 [running →ready] : 인터럽트 (Interrupt) - 예외, 입출력, 이벤트 등이 발생하여 현재 실행 중인 프로세스를 준비 상태로 바꾸고, 
                    해당 작업을 먼저 처리하는 것.
```
6.  라운드 로빈이 무엇이고 time slice가 작거나 크면 어떤 단점이 있나요?
```
프로세스들 사이에 우선순위를 두지 않고, 순서대로 시간단위(Time Quantum/Slice)로 CPU를 할당하는 방식의 CPU 스케줄링 알고리즘입니다.
할당 시간(time slice)이 크면 FCFS와 같게 되고, 작으면 문맥 교환 (Context Switching) 잦아져서 오버헤드 증가
```
#### 김빛누리
1. 프로세스 간 통신 종류, 간단히 설명

```
- 공유 메모리: 프로세스 간 메모리 영역 공유, 
프로세스가 공유 메모리 할당을 커널에 요청하면 커널은 해당 프로세스에 메모리 공간을 할당한다.
중개자 없이 메모리에 접근이 가능해 IPC 중 가장 속도가 빠르다

- 파이프: 익명 파이프, 네임드 파이프
익명 파이프는 부모-자식 관계처럼 통신할 프로세스가 명확할 때 사용
네임드 파이프는 익명 파이프의 확장된 상태로 부모 프로세스와 무관한 다른 프로세스도 통신 가능,
통신을 위해 이름이 있는 파일을 사용하며 외부 프로세스와 통신이 가능하다.

- 소켓: 네트워크 소켓 통신을 통해 데이터를 공유, 
원격에서 프로세스 간 데이터를 공유할 때 사용

- 메시지 큐: 입출력 방식은 Named 파이프와 동일하지만 파이프처럼 데이터의 흐름이 아닌
메모리를 이용하는 방식이며 다수의 프로세스간 메시지를 전달할 수 있다

- 메모리 맵: 열린 파일을 메모리에 맵핑시켜서 공유, 파일로 대용량 데이터를 공유해야 할 때 사용
```

2. CPU 스케줄링 선점 / 비선점 설명

```
선점: 우선 순위가 높은 다른 프로세스가 현재 프로세스를 중단시키고 
CPU를 점유하는 스케줄링 방식 (처리시간 예측 어려움)

비선점: 하나의 프로세스가 CPU를 할당 받으면, 
작업 종료 후 CPU 반환 시까지 다른 프로세스가 CPU를 점유할 수 없는 스케줄링 방식
(처리시간 예측 용이함)
```

- 프로세스 상태 전이 어떤 것 있는지?
    ```
    승인(Admitted): 프로세스 생성이 가능하여 승인됨.
    스케줄러 디스패치(Scheduler Dispatch): 준비 상태에 있는 프로세스 중 하나를 선택하여 실행시키는 것.
    인터럽트(Interrupt): 예외, 입출력, 이벤트 등이 발생하여 현재 실행 중인 프로세스를 준비 상태로 바꾸고, 해당 작업을 먼저 처리하는 것.
    입출력 또는 이벤트 대기(I/O or Event wait): 실행 중인 프로세스가 입출력이나 이벤트를 처리해야 하는 경우, 입출력/이벤트가 모두 끝날 때까지 대기 상태로 만드는 것.
    입출력 또는 이벤트 완료(I/O or Event Completion): 입출력/이벤트가 끝난 프로세스를 준비 상태로 전환하여 스케줄러에 의해 선택될 수 있도록 만드는 것
    ```

- CPU 스케줄링 척도 아는대로
    ```
    응답시간(Response time)
    반환시간(Turnaround time)
    시간당 처리량(Throughput)
    ```

3. 데드락이 어떤것인지, 발생조건?
```
두 개 이상의 작업이 서로 상대방의 작업이 끝나기 만을 기다리고 있기 때문에 
결과적으로 아무것도 완료되지 못하는 상태

[조건]
- 상호 배제
- 점유 대기
- 비선점
- 순환 대기
```

- 데드락 발생 처리 방법?
    ```
    예방, 회피, 탐지 및 회복

    예방: 데드락 발생조건 중 하나를 제거
    회피: 데드락 피하는 방법
    탐지 및 회복: 교착 상태가 되도록 허용한 다음 회복한다. 탐지 -> 회복
    ```

#### 김주영

1. PCB란 무엇인가요? 어떤 정보가 저장되나요?
```
- 프로세스의 정보를 가지고 있음 (프로세스의 메타데이터)
- ID, State, Register, Memory Usage 등
```

1-2. PCB의 생성 과정에 대해 말해주세요
```
- 프로그램이 실행되고 프로세스가 생성 되면 주소 공간에 (코드, 데이터, 스택) 생성
- 이런 프로세스의 메타데이터가 PCB에 저장
```

2. Context switching이 언제 일어나나요?
```
- I/O 요청, 인터럽트 처리
- 멀티태스킹시 프로세스들이 운영체제의 스케줄러에 의해 번갈아 가며 수행될 때
```

2-2. CPU 스케줄링 중에 설명할 수 있는 것 하나만 해주세요
```
- FCFS (First Come First Served)
- SJF (Shortest-Job-First)
- Priority 
- Round Robin
```

2-3. 본인이 생각하기에 CPU 스케줄링 척도가 가장 좋다고 생각하는 것은?
```
- 정말 자신의 생각을 말해주세요
- 개인적으로 저의 생각은 RR + PS (Round Robin + Priority )
```

2-4. Context Switching는 결국 CPU가 놀지 않도록 만들기 위한 것인데, 이는 프로그램의 어떤 목적을 위해서인가?
```
- Concurrency
```

2-5. 스레드와 프로세스 중 context switching이 빠른 것과 그 이유는?
```
- thread가 stack을 제외한 코드,데이터,힙 영역을 공유하기 때문에 PCB에 스택 및 간단한 정보만 저장하기 때문에 더 빠름
```

3. IPC란 ?
```
- Process끼리 데이터를 주고 받고, 공유 데이터를 관리하는 메커니즘
```

3-2. IPC에서 프로세스 간 데이터를 보호하기 위해 사용하는 방법은?
```
- 세마포어, 뮤텍스
```
    
#### 장시우
1. IPC 종류
```
익명 PIPE : 한쪽 방향으로만 통신이 가능한 반이중 통신
Named PIPE : 부모 프로세스와 무관한 다른 프로세스도 통신이 가능한 것
Message Queue : 입출력 방식은 Named 파이프와 동일함, 다른점은 메시지 큐는 파이프처럼 데이터의 흐름이 아니라 메모리 공간이다.
공유 메모리 : 공유 메모리는 데이터 자체를 공유하도록 지원하는 설비
메모리 맵 : 열린 파일을 메모리에 맵핑시켜서 공유
소켓 : 네트워크 소켓 통신을 통해 데이터를 공유한다.
```
2.. 선점 / 비선점 스케줄링
```
선점( preemptive ) : OS가 CPU의 사용권을 선점할 수 있는 경우, 강제 회수하는 경우( 처리시간 예측 어려움 )
비선점( nonpreemptive ) : 프로세스 종료 or I/O 등의 이벤트가 있을 때까지 실행 보장( 처리시간 예측 용이함 )
```
2-1. 프로세스의 상태 전이
```
승인 : 프로세스 생성이 가능하여 승인됨
스케줄러 디스패치 : 준비 상태에 있는 프로세스 중 하나를 선택하여 실행시키는 것
인터럽트 : 예외, 입출력, 이벤트 등이 발생하여 현재 실행 중인 프로세스를 준비 상태로 바꾸고, 해당 작업을 먼저 처리하는 것
입출력 또는 이벤트 대기 : 실행 중인 프로세스가 입출력이나 이벤트를 처리해야 하는 경우, 입출력/이벤트가 모두 끝날 때까지 대기 상태로 만드는 것
입출력 또는 이벤트 완료 : 입출력/이벤트가 끝난 프로세스를 준비 상태로 전환하여 스케줄러에 의해 선택될 수 있도록 만드는 것
```
3. 데드락
```
두 개 이상의 프로세스나 스레드가 서로 자원을 얻지 못해서 다음 처리를 하지 못하는 상태
무한히 다음 자원을 기다리게 되는 상태를 말한다.
시스템적으로 한정된 자원을 여러 곳에서 사용하려고 할 때 발생한다.
```
3-1. 데드락 발생 조건
```
상호 배제, 점유 대기, 비선점, 순환 대기
```
3-2. 교착상태 처리
```
예방 : 교착 상태 발생 조건 중 하나를 제거하면서 해결한다.
회피 : 교착 상태 발생 시 피해나가는 방법( 은행원 알고리즘 )
```
