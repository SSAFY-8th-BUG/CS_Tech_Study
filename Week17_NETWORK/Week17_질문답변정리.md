# Week 17 - 질문/답변 정리

#### 권혁근
1. 로드 벨런싱이란 무엇인가?
```
로드 벨런싱은 분산식 웹 서비스로, 여러 서버에 부하(Load)를 나누어주는 역할을 한다. Load Balancer를 클라이언트와 서버 사이에 두고, 부하가 일어나지 않도록 여러 서버에 분산시켜주는 방식이다.
```
2. 로드 밸런서가 서버를 선택하는 방식은 어떤 것들이 있는가?
```
- 라운드 로빈(Round Robin) : CPU 스케줄링의 라운드 로빈 방식 활용
- Least Connections : 연결 개수가 가장 적은 서버 선택 (트래픽으로 인해 세션이 길어지는 경우 권장)
- Source : 사용자 IP를 해싱하여 분배 (특정 사용자가 항상 같은 서버로 연결되는 것 보장)
```
3. Blocking/Non-blocking 차이는 무엇인가?
```
블럭/논블럭은 간단히 말해서 호출된 함수가 호출한 함수에게 제어권을 건네주는 유무의 차이
- Blocking : 호출된 함수가 일을 마칠 때까지 기다리고 일을 마치면 제어권을 갖는다.
- Non-blocking : 호출된 함수가 일을 시작할 때 바로 제어권을 리턴 받는다. 즉 다른 작업을 할 수 있다.
```
4. Synchronous/Asynchronous 차이는 무엇인가?
```
호출한 함수 B의 수행 결과나 종료 상태를 A가 신경쓰고 있는 유무의 차이
- Synchronous : 함수 A는 호출된 함수 B가 일을 하는 중에 기다리면서, 현재 상태가 어떤지 계속 체크한다.
- Asynchronous : 호출된 함수 B의 수행 상태를 B 혼자 직접 신경쓰면서 처리한다. Callback을 전달 받아 작업의 완료 여부를 확인함
```
5. Blocking I/O & Non-Blocking I/O 의 차이점은 무엇인가?
```
Blocking I/O는 시스템 콜이 들어오면 커널은 IO작업이 완료되기 전에는 응답하지 않고 제어권을 커널이 갖고 있다. 그렇기에 시스템 콜을 보낸 후에 유저 프로세스는 응답을 받기 전에는 다른 작업을 하지 못한다.
Non-Blocking I/O는 시스템 콜이 들어오면 IO 작업의 완료 여부와는 무관하게 즉시 응답을 한다. 이는 제어권을 유저 프로세스에게 넘겨주는 것이므로 다른 작업을 할 수 있다. 유저 프로세스는 다른 작업을 수행하다가 중간 중간에 시스템 콜을 보내 IO가 완료되었는지 확인한고 완료되면 종료된다.
```

#### 박상민
1. 로드 밸런서는 무엇이며 장애가 생겼을 때 어떻게 대비해야하나요?
```
수많은 사용자가 접속하는 트래픽을 감당하기에 1대의 서버로는 부족하다. 그래서 하드웨어의 성능을 올리거나 서버가 나눠서 일하도록 만드는 방법이 있는데 이 나눠서 일하도록하는 방법이 로드 밸런싱이다.
로드 밸런서가 장애가 생기는 경우를 대비해서 로드 밸런서를 2개 이상 준비하여 백업용으로 준비해놓음으로써 이중화하여 대비한다.
```
2. 블록킹과 논 블록킹의 차이점은 무엇인가요?
```
블록킹은 할일을 다마칠때까지 제어권을 잡고 있는 것이고 논 블록킹은 할일을 다 마치지 않아도 제어권을 넘기는 방식이다.
```
3. SSL은 무엇이며 통신과정을 간략하게 설명해주세요
```
- 클라이언트/서버 응용 프로그램이 네트워크로 통신을 하는 과정에서 도청, 간섭, 위조를 방지하기 위해서 설계된 프로토콜이다.
- HTTPS 에서 클라이언트와 서버간 통신전 신뢰성 여부를 판단하기 위해 사용된다.
1. 랜덤한 데이터와 현재 지원가능한 암호화방식 목록을 서버에게 전달
2. 인증서(공개키)와 랜덤한데이터, 클라이언트에서 전달한 암호화 방식 목록 중 가장 안전한 암호화 수단 방식을 클라이언트에 전달
3. CA의 공개키를 이용해서 서버가 보낸 인증서를 복호화
    
    서버가 전송한 랜덤한 데이터를 조합하여 Pre Master Secret 키를 생성
    
4. 서버 공개키를 이용하여 Pre Master Secret를 암호화하여 서버로 전송
5. Pre Master Secret 값을 Master Secret 값으로 만듬
Session Key 를 만듬
6. Session Key 를 이용하여 암호화하여 데이터를 주고받음 (대칭키 방식)
```

#### 장시우
1. 로드 밸런싱이란?
```
둘 이상의 CPU or 저장장치와 같은 컴퓨터 자원들에게 작업을 나누는 것
요즘 시대에는 웹사이트에 접속하는 인원이 급격히 늘어나게 되었다.
따라서 이 사람들에 대해 모든 트래픽을 감당하기엔 1대의 서버로는 부족하다. 대응 방안으로 하드웨어의 성능을 올리거나(Scale-up) 여러대의 서버가 나눠서 일하도록 만드는 것(Scale-out)이 있다.
하드웨어 향상 비용이 더욱 비싸기도 하고, 서버가 여러대면 무중단 서비스를 제공하는 환경 구성이 용이하므로 Scale-out이 효과적이다. 이때 여러 서버에게 균등하게 트래픽을 분산시켜주는 것이 바로 로드 밸런싱이다.
로드 밸런싱은 분산식 웹 서비스로, 여러 서버에 부하(Load)를 나누어주는 역할을 한다. Load Balancer를 클라이언트와 서버 사이에 두고, 부하가 일어나지 않도록 여러 서버에 분산시켜주는 방식이다. 서비스를 운영하는 사이트의 규모에 따라 웹 서버를 추가로 증설하면서 로드 밸런서로 관리해주면 웹 서버의 부하를 해결할 수 있다.
```
2. Blocking/Non-blocking 의 차이점은 무엇인가?
```
블럭/논블럭은 간단히 말해서 호출된 함수가 호출한 함수에게 제어권을 건네주는 유무의 차이라고 볼 수 있다.

함수 A, B가 있고, A 안에서 B를 호출했다고 가정해보자. 이때 호출한 함수는 A고, 호출된 함수는 B가 된다. 현재 B가 호출되면서 B는 자신의 일을 진행해야 한다. (제어권이 B에게 주어진 상황)

Blocking : 함수 B는 내 할 일을 다 마칠 때까지 제어권을 가지고 있는다. A는 B가 다 마칠 때까지 기다려야 한다.
Non-blocking : 함수 B는 할 일을 마치지 않았어도 A에게 제어권을 바로 넘겨준다. A는 B를 기다리면서도 다른 일을 진행할 수 있다.
즉, 호출된 함수에서 일을 시작할 때 바로 제어권을 리턴해주느냐, 할 일을 마치고 리턴해주느냐에 따라 블럭과 논블럭으로 나누어진다고 볼 수 있다.
```
3. Synchronous/Asynchronous 의 차이점은 무엇인가?
```
동기/비동기는 일을 수행 중인 동시성에 주목하자

아까처럼 함수 A와 B라고 똑같이 생각했을 때, B의 수행 결과나 종료 상태를 A가 신경쓰고 있는 유무의 차이라고 생각하면 된다.

Synchronous : 함수 A는 함수 B가 일을 하는 중에 기다리면서, 현재 상태가 어떤지 계속 체크한다.
Asynchronous : 함수 B의 수행 상태를 B 혼자 직접 신경쓰면서 처리한다. (Callback)
즉, 호출된 함수(B)를 호출한 함수(A)가 신경쓰는지, 호출된 함수(B) 스스로 신경쓰는지를 동기/비동기라고 생각하면 된다.

비동기는 호출시 Callback을 전달하여 작업의 완료 여부를 호출한 함수에게 답하게 된다. (Callback이 오기 전까지 호출한 함수는 신경쓰지 않고 다른 일을 할 수 있음)
```
4. Blocking I/O, Non-Blocking I/O 의 차이점은 무엇인가?
```
I/O Blocking 형태의 작업은

(1) Process(Thread)가 Kernel에게 I/O를 요청하는 함수를 호출

(2) Kernel이 작업을 완료하면 작업 결과를 반환 받음.

특징
I/O 작업이 진행되는 동안 user Process(Thread) 는 자신의 작업을 중단한 채 대기
Resource 낭비가 심함
(I/O 작업이 CPU 자원을 거의 쓰지 않으므로)
여러 Client 가 접속하는 서버를 Blocking 방식으로 구현하는 경우 -> I/O 작업을 진행하는 작업을 중지 -> 다른 Client가 진행중인 작업을 중지하면 안되므로, client 별로 별도의 Thread를 생성해야 함 -> 접속자 수가 매우 많아짐
이로 인해, 많아진 Threads 로 컨텍스트 스위칭 횟수가 증가함,,, 비효율적인 동작 방식

I/O 작업이 진행되는 동안 User Process의 작업을 중단하지 않음.

진행 순서
User Process가 recvfrom 함수 호출 (커널에게 해당 Socket으로부터 data를 받고 싶다고 요청함)
Kernel은 이 요청에 대해서, 곧바로 recvBuffer를 채워서 보내지 못하므로, "EWOULDBLOCK"을 return함.
Blocking 방식과 달리, User Process는 다른 작업을 진행할 수 있음.
recvBuffer에 user가 받을 수 있는 데이터가 있는 경우, Buffer로부터 데이터를 복사하여 받아옴.
이때, recvBuffer는 Kernel이 가지고 있는 메모리에 적재되어 있으므로, Memory간 복사로 인해, I/O보다 훨씬 빠른 속도로 data를 받아올 수 있음.
recvfrom 함수는 빠른 속도로 data를 복사한 후, 복사한 data의 길이와 함께 반환함.
```
